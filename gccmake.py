import os

def scan_source_codes(project_dir, sub_dir, exclude_dirs, include_files, source_files):

    # Finds source codes in directory
    if not project_dir.endswith('/'):
       project_dir = project_dir + '/';
    
    dir = project_dir;
    if len(sub_dir)>0:
        dir = project_dir + sub_dir + '/';
    for file_loop1 in os.listdir(dir):
        file = dir + file_loop1;
        if (os.path.isfile(file)):
            #file found, checks file extensions
            if file_loop1.endswith('.c')\
            or file_loop1.endswith('.cpp')\
            or file_loop1.endswith('.s'):  
                s = file_loop1;
                if (len(sub_dir)>0):
                  s = sub_dir + '/' + file_loop1;
                source_files.append(s);
                
            if file_loop1.endswith('.h')\
            or file_loop1.endswith('.hpp'):
                if len(sub_dir)>0:
                    if (not sub_dir in include_files):
                        include_files.append(sub_dir);

        elif (os.path.isdir(file)):
            # directory found - checks whether it contains just
            # source codes or it contais sub project definition
            
            skip_dir = False;
            for ex_dir in exclude_dirs:
                if (file_loop1 == ex_dir):
                    skip_dir = True;
            if (skip_dir):
                continue; 

            sub_project_found = False;         
            if (file_loop1 != '.git'):
                
                for file_loop2 in os.listdir(file):
                    # checks whether directory contains another 
                    # project definition or it is root directory
                    # of another git module
                    if file_loop2.endswith('.vcproj')\
                    or file_loop2.endswith('.uvproj')\
                    or file_loop2.endswith('.project')\
                    or file_loop2.endswith('.git'):
                            sub_project_found = True;

            if (sub_project_found):
                include_files_2 = [];
                source_files_2 = [];
                scan_source_codes(file, '', exclude_dirs, include_files_2, source_files_2);
            else:
                s = file_loop1;
                if len(sub_dir)>0:
                  s = sub_dir + '/' + file_loop1;
                scan_source_codes(project_dir, s, exclude_dirs, include_files, source_files);
                
    if (len(sub_dir)==0):
        print("Root: " + project_dir + " Dir: " + sub_dir);
        print(include_files);
        print(source_files);


def main():
    target_name = "PersistenceLibrary";
    target_ext  = ".a";
    target_is_lib = True;
    
    include_files= [];
    source_files = [];
    exclude_dirs = ('.git', 'IDE', 'Examples');
    scan_source_codes('/home/PersistenceLibrary/', '', exclude_dirs, include_files, source_files);
    
    makefile = open("makefile", "w");
    makefile.write("#      Makefile generated by GCCMake\n");
    makefile.write("# @ 2020 Ondrej Sterba, osterba@atlas.cz\n");
    makefile.write("# \n");
    makefile.write("# GENERATED MAKEFILE IS PROVIDED \"AS IS\" AND ANY EXPRESS\n");
    makefile.write("# OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n");
    makefile.write("# WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n");
    makefile.write("# ARE DISCLAIMED.\n");    
    makefile.write("\n");
    makefile.write("# Standard GCC platform\n");
    makefile.write("CC	= gcc\n");
    makefile.write("CPP	= g++\n");
    makefile.write("AS	= as\n");
    makefile.write("LD	= ld\n");
    makefile.write("CP	= objcopy\n");
    makefile.write("OS	= size\n");
    makefile.write("OD	= objdump\n");
    makefile.write("\n");
    makefile.write("CPPFLAGS  = -g -std=c++11\n");
    makefile.write("CFLAGS  = -g -std=c99\n");
    makefile.write("ASFLAGS = -g\n");
    makefile.write("LDFLAGS = \n");
    makefile.write("\n");    
    makefile.write("# The rest (in the included file) is platform independent\n");
    makefile.write("include makefile.mk\n");
    makefile.close();
    makefile = open("makefile.mk", "w");
    makefile.write("#      Makefile generated by GCCMake\n");
    makefile.write("# @ 2020 Ondrej Sterba, osterba@atlas.cz\n");
    makefile.write("# \n");
    makefile.write("# GENERATED MAKEFILE IS PROVIDED \"AS IS\" AND ANY EXPRESS\n");
    makefile.write("# OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n");
    makefile.write("# WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n");
    makefile.write("# ARE DISCLAIMED.\n");    
    makefile.write("\n");
    makefile.write("PROJECT = " + target_name + "\n");
    makefile.write("OUTPUTFILE =$(PROJECT)" + target_ext + "\n");
    makefile.write("SRCDIR = ./\n");
    makefile.write("\n");
    makefile.write("# Includes source files from all subdirectories\n");
    makefile.write("INC +=\\\n");
    for inc_file in include_files:
        makefile.write("      -I$(SRCDIR)" + inc_file + "\\\n");
    makefile.write("\n");
    makefile.write("SRC +=\\\n");
    for src_file in source_files:
        makefile.write("      $(SRCDIR)" + src_file + "\\\n");
    makefile.write("\n");    
    makefile.write("#  C++ source files\n");
    makefile.write("CPPFILES = $(filter %.cpp, $(SRC))\n");
    makefile.write("#  C source files\n");
    makefile.write("CFILES = $(filter %.c, $(SRC))\n");
    makefile.write("#  Assembly source files\n");
    makefile.write("ASMFILES = $(filter %.s, $(SRC))\n");
    makefile.write("\n");
    makefile.write("# Object files\n");
    makefile.write("CPPOBJ = $(CPPFILES:.cpp=.o)\n");
    makefile.write("COBJ = $(CFILES:.c=.o)\n");
    makefile.write("SOBJ = $(ASMFILES:.s=.o)\n");
    makefile.write("OBJ  = $(CPPOBJ) $(COBJ) $(SOBJ)\n");
    makefile.write("\n");
    makefile.write("all: $(OUTPUTFILE)\n");
    makefile.write("\n");
    makefile.write("# Output file requires all object files first.\n");
    makefile.write("# All object files are packed to static library then.\n");
    makefile.write("$(OUTPUTFILE): $(OBJ)\n");
    if target_is_lib:
        makefile.write("\techo Archiving\n");
        makefile.write("\t@$(AR) rc $(OUTPUTFILE) $(OBJ)\n");
        makefile.write("\t@echo $(OUTPUTFILE)\n");
    else:
        makefile.write("\techo Linking\n");
        makefile.write("\t$(LD) $(LDFLAGS) $(OBJ) -o $@\n");
        if (target_size):
            makefile.write("\t$(OS) -t $(PROJECT)" + target_ext + "\n");
    makefile.write("\n");
    makefile.write("$(CPPOBJ): %.o: %.cpp\n");
    makefile.write("\t@echo $<;\n");
    makefile.write("\t@$(CPP) -c $(INC) $(CPPFLAGS) $(LIBDIR)  $< -o $@ \n");
    makefile.write("\n");
    makefile.write("$(COBJ): %.o: %.c\n");
    makefile.write("\t@echo $<;\n");
    makefile.write("\t@$(CC) -c $(INC) $(CFLAGS) $(LIBDIR) $< -o $@ \n");
    makefile.write("\n");
    makefile.write("$(SOBJ): %.o: %.s\n");
    makefile.write("\t@echo $<;\n");
    makefile.write("\t@$(AS) -c $(ASFLAGS) $< -o $@\n");
    makefile.write("\n");
    makefile.write("clean:\n");
    makefile.write("\t@rm -f $(OUTPUTFILE) $(OBJ)\n");
    makefile.write("\n");
    makefile.close();
    

if __name__ == "__main__":
    main()